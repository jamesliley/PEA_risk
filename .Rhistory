dates["/Users/vwbw55/Personal/Matthew/Photo_a_day/Photos_original//A878329F-9CE8-48F2-B3DF-E341698D4AA7.JPG"] = as.Date("2023-03-25")
dates=dates[names(metadata)]
xord=order(dates)
# Reorder by dates
photo_names=photo_names[xord]
l_eye=l_eye[xord,]
r_eye=r_eye[xord,]
dates=dates[xord]
metadata=metadata[xord]
nphoto=length(photo_names)
nphoto
# Indices of good photos and facing-forward photos ####
indexfile="~/Personal/Matthew/Photo_a_day/indexdata.RData"
if (!file.exists(indexfile)) {
### Photos facing forward and clear
fclear_index=c(2,3,7,9,12,14,16,20,21,22,27,28,30,31,33,34,36,37,41,42,48,50,
53,54,55,57,59,62,65,67,68,69,72,75,77,80,81,82,84,85,86,87,
90,92,93,97,100,101,105,106,108,109,110,112,113,114,115,116,
119,120,121,122,125,126,127,128,130,132,135,136,137,138,139,
141,145,146,147,148,151,152,153,154,158,159,163,164,165,166,
167,169,171,172,174,175,178,181,182,184,185,186,190,192,
193,194,195,197,198,199,200,201,203,204,205,208,209,210,211,
215,216,217,219,220,221,222,223,224,225,227,228,230,231,232,234,
235,237,238,241,242,243,244,250,255,256,258,259,260,263,
264,266,268,272,274,275,277,278,280,281,283,284,285,286,289,
290,291,292,294,297,300,305,308,309,311,312,313,316,320,
322,323,324,326,328,329,331,332,336,340,341,343,345,347,348,
349,351,352,353,357,358,359,362,363,366,368,369,370,372,373,
375,377,382,383,386,391,393,395,399,400,404,409,
411,413,415,416,417,419,422,424,425,426,427,428,429,430,432)
fclear=photo_names[fclear_index]
### Good photos to stop at
fstop_index=c(1,11,39,56,74,109,147,191,199,213,231,
246,258,274,285,311,330,344,368,411,417)
fstop=photo_names[fstop_index]
save(fclear,fstop,file=indexfile)
} else load(indexfile)
fi=match(fclear,photo_names)
scxj=seq(2,0.5,length=length(fclear))
i=length(fclear)
i=fi[j]
par(pty="s")
plot(0,xlim=c(-3,3),ylim=c(-3,3),type="n",bty="n",ann=F,xaxt="n",yaxt="n")
picx=readJPEG(photo_names[i])
dm=dim(picx)[1]/dim(picx)[2]
L=as.numeric(l_eye[i,1:2]); R=as.numeric(r_eye[i,1:2]);
L[2]=L[2]*dm; R[2]=R[2]*dm
emid=(L+R)/2 # midpoint of eyes
edist=sqrt(sum((R-L)^2)) # distance between eyes
theta=atan((R[2]-L[2])/(R[1]-L[1])) # angle through which to rotate picture
if (L[1]>R[1]) theta = theta + pi # correction for error
phi=-atan(emid[2]/emid[1]) # angle to midpoint of eyes
dmid=sqrt(sum(emid^2)) # distance from bottom left corner to midpoint of eyes
emidr=dmid*c(cos(theta+phi),-sin(theta+phi)) # co-ordinates of midpoint in rotated image
sc=1/edist
# Adjust brightness
L=as.numeric(l_eye[i,1:2]); R=as.numeric(r_eye[i,1:2]);
L1=L*dim(picx)[2:1];   R1=R*dim(picx)[2:1]; mm = (L1+R1)/2; mm=mm[2:1];
mm[1]=dim(picx)[1]-mm[1]
dd=(3/4)*sqrt(sum((L1-R1)^2))
dx=outer(1:dim(picx)[1],1:dim(picx)[2],function(x,y) sqrt((x-mm[1])^2 + (y-mm[2])^2))
ww=which(dx<dd)
bx1=mean(picx[,,1][ww])
bx2=mean(picx[,,2][ww])
bx3=mean(picx[,,3][ww])
sc1=0.7/bx1; sc2=0.44/bx2; sc3=0.3/bx3
picx[,,1]=pmin(1,picx[,,1]*sc1)
picx[,,2]=pmin(1,picx[,,2]*sc2)
picx[,,3]=pmin(1,picx[,,3]*sc3)
# Plot
s0=scxj[j]
rasterImage(picx,-s0*sc*emidr[1],-s0*sc*emidr[2],s0*sc*(1-emidr[1]),s0*sc*(dm-emidr[2]),
angle=-theta*180/pi)
#points(0,0,pch=16,cex=2,col="red")
j=length(fclear)
i=fi[j]
par(pty="s")
plot(0,xlim=c(-3,3),ylim=c(-3,3),type="n",bty="n",ann=F,xaxt="n",yaxt="n")
picx=readJPEG(photo_names[i])
dm=dim(picx)[1]/dim(picx)[2]
L=as.numeric(l_eye[i,1:2]); R=as.numeric(r_eye[i,1:2]);
L[2]=L[2]*dm; R[2]=R[2]*dm
emid=(L+R)/2 # midpoint of eyes
edist=sqrt(sum((R-L)^2)) # distance between eyes
theta=atan((R[2]-L[2])/(R[1]-L[1])) # angle through which to rotate picture
if (L[1]>R[1]) theta = theta + pi # correction for error
phi=-atan(emid[2]/emid[1]) # angle to midpoint of eyes
dmid=sqrt(sum(emid^2)) # distance from bottom left corner to midpoint of eyes
emidr=dmid*c(cos(theta+phi),-sin(theta+phi)) # co-ordinates of midpoint in rotated image
sc=1/edist
# Adjust brightness
L=as.numeric(l_eye[i,1:2]); R=as.numeric(r_eye[i,1:2]);
L1=L*dim(picx)[2:1];   R1=R*dim(picx)[2:1]; mm = (L1+R1)/2; mm=mm[2:1];
mm[1]=dim(picx)[1]-mm[1]
dd=(3/4)*sqrt(sum((L1-R1)^2))
dx=outer(1:dim(picx)[1],1:dim(picx)[2],function(x,y) sqrt((x-mm[1])^2 + (y-mm[2])^2))
ww=which(dx<dd)
bx1=mean(picx[,,1][ww])
bx2=mean(picx[,,2][ww])
bx3=mean(picx[,,3][ww])
sc1=0.7/bx1; sc2=0.44/bx2; sc3=0.3/bx3
picx[,,1]=pmin(1,picx[,,1]*sc1)
picx[,,2]=pmin(1,picx[,,2]*sc2)
picx[,,3]=pmin(1,picx[,,3]*sc3)
# Plot
s0=scxj[j]
rasterImage(picx,-s0*sc*emidr[1],-s0*sc*emidr[2],s0*sc*(1-emidr[1]),s0*sc*(dm-emidr[2]),
angle=-theta*180/pi)
#points(0,0,pch=16,cex=2,col="red")
j
fclear[j]
grep("birthday",photo_names)
### Photos facing forward and clear
fclear_index=c(2,3,7,9,12,14,16,20,21,22,27,28,30,31,33,34,36,37,41,42,48,50,
53,54,55,57,59,62,65,67,68,69,72,75,77,80,81,82,84,85,86,87,
90,92,93,97,100,101,105,106,108,109,110,112,113,114,115,116,
119,120,121,122,125,126,127,128,130,132,135,136,137,138,139,
141,145,146,147,148,151,152,153,154,158,159,163,164,165,166,
167,169,171,172,174,175,178,181,182,184,185,186,190,192,
193,194,195,197,198,199,200,201,203,204,205,208,209,210,211,
215,216,217,219,220,221,222,223,224,225,227,228,230,231,232,234,
235,237,238,241,242,243,244,250,255,256,258,259,260,263,
264,266,268,272,274,275,277,278,280,281,283,284,285,286,289,
290,291,292,294,297,300,305,308,309,311,312,313,316,320,
322,323,324,326,328,329,331,332,336,340,341,343,345,347,348,
349,351,352,353,357,358,359,362,363,366,368,369,370,372,373,
375,377,382,383,386,391,393,395,399,400,404,409,
411,413,415,416,417,419,422,424,425,426,427,428,429,430,432)
fclear=photo_names[fclear_index]
### Good photos to stop at
fstop_index=c(1,11,39,56,74,109,147,191,199,213,231,
246,258,274,285,311,330,344,368,411,417)
fstop=photo_names[fstop_index]
save(fclear,fstop,file=indexfile)
load(indexfile)
j=length(fclear)
i=fi[j]
par(pty="s")
plot(0,xlim=c(-3,3),ylim=c(-3,3),type="n",bty="n",ann=F,xaxt="n",yaxt="n")
picx=readJPEG(photo_names[i])
dm=dim(picx)[1]/dim(picx)[2]
L=as.numeric(l_eye[i,1:2]); R=as.numeric(r_eye[i,1:2]);
L[2]=L[2]*dm; R[2]=R[2]*dm
emid=(L+R)/2 # midpoint of eyes
edist=sqrt(sum((R-L)^2)) # distance between eyes
theta=atan((R[2]-L[2])/(R[1]-L[1])) # angle through which to rotate picture
if (L[1]>R[1]) theta = theta + pi # correction for error
phi=-atan(emid[2]/emid[1]) # angle to midpoint of eyes
dmid=sqrt(sum(emid^2)) # distance from bottom left corner to midpoint of eyes
emidr=dmid*c(cos(theta+phi),-sin(theta+phi)) # co-ordinates of midpoint in rotated image
sc=1/edist
# Adjust brightness
L=as.numeric(l_eye[i,1:2]); R=as.numeric(r_eye[i,1:2]);
L1=L*dim(picx)[2:1];   R1=R*dim(picx)[2:1]; mm = (L1+R1)/2; mm=mm[2:1];
mm[1]=dim(picx)[1]-mm[1]
dd=(3/4)*sqrt(sum((L1-R1)^2))
dx=outer(1:dim(picx)[1],1:dim(picx)[2],function(x,y) sqrt((x-mm[1])^2 + (y-mm[2])^2))
ww=which(dx<dd)
bx1=mean(picx[,,1][ww])
bx2=mean(picx[,,2][ww])
bx3=mean(picx[,,3][ww])
sc1=0.7/bx1; sc2=0.44/bx2; sc3=0.3/bx3
picx[,,1]=pmin(1,picx[,,1]*sc1)
picx[,,2]=pmin(1,picx[,,2]*sc2)
picx[,,3]=pmin(1,picx[,,3]*sc3)
# Plot
s0=scxj[j]
rasterImage(picx,-s0*sc*emidr[1],-s0*sc*emidr[2],s0*sc*(1-emidr[1]),s0*sc*(dm-emidr[2]),
angle=-theta*180/pi)
fi[j]
fclear[j]
which(photo_names==fclear[j])
length(fclear)
fi[233]
fi=match(fclear,photo_names)
fi[233]
fi=match(fclear,photo_names)
scxj=seq(2,0.5,length=length(fclear))
i=fi[j]
par(pty="s")
plot(0,xlim=c(-3,3),ylim=c(-3,3),type="n",bty="n",ann=F,xaxt="n",yaxt="n")
picx=readJPEG(photo_names[i])
dm=dim(picx)[1]/dim(picx)[2]
L=as.numeric(l_eye[i,1:2]); R=as.numeric(r_eye[i,1:2]);
L[2]=L[2]*dm; R[2]=R[2]*dm
emid=(L+R)/2 # midpoint of eyes
edist=sqrt(sum((R-L)^2)) # distance between eyes
theta=atan((R[2]-L[2])/(R[1]-L[1])) # angle through which to rotate picture
if (L[1]>R[1]) theta = theta + pi # correction for error
phi=-atan(emid[2]/emid[1]) # angle to midpoint of eyes
dmid=sqrt(sum(emid^2)) # distance from bottom left corner to midpoint of eyes
emidr=dmid*c(cos(theta+phi),-sin(theta+phi)) # co-ordinates of midpoint in rotated image
sc=1/edist
# Adjust brightness
L=as.numeric(l_eye[i,1:2]); R=as.numeric(r_eye[i,1:2]);
L1=L*dim(picx)[2:1];   R1=R*dim(picx)[2:1]; mm = (L1+R1)/2; mm=mm[2:1];
mm[1]=dim(picx)[1]-mm[1]
dd=(3/4)*sqrt(sum((L1-R1)^2))
dx=outer(1:dim(picx)[1],1:dim(picx)[2],function(x,y) sqrt((x-mm[1])^2 + (y-mm[2])^2))
ww=which(dx<dd)
bx1=mean(picx[,,1][ww])
bx2=mean(picx[,,2][ww])
bx3=mean(picx[,,3][ww])
sc1=0.7/bx1; sc2=0.44/bx2; sc3=0.3/bx3
picx[,,1]=pmin(1,picx[,,1]*sc1)
picx[,,2]=pmin(1,picx[,,2]*sc2)
picx[,,3]=pmin(1,picx[,,3]*sc3)
# Plot
s0=scxj[j]
rasterImage(picx,-s0*sc*emidr[1],-s0*sc*emidr[2],s0*sc*(1-emidr[1]),s0*sc*(dm-emidr[2]),
angle=-theta*180/pi)
j=j-1
plot(dates)
i=431
par(pty="s")
plot(0,xlim=c(-3,3),ylim=c(-3,3),type="n",bty="n",ann=F,xaxt="n",yaxt="n")
picx=readJPEG(photo_names[i])
dm=dim(picx)[1]/dim(picx)[2]
L=as.numeric(l_eye[i,1:2]); R=as.numeric(r_eye[i,1:2]);
L[2]=L[2]*dm; R[2]=R[2]*dm
emid=(L+R)/2 # midpoint of eyes
edist=sqrt(sum((R-L)^2)) # distance between eyes
theta=atan((R[2]-L[2])/(R[1]-L[1])) # angle through which to rotate picture
if (L[1]>R[1]) theta = theta + pi # correction for error
phi=-atan(emid[2]/emid[1]) # angle to midpoint of eyes
dmid=sqrt(sum(emid^2)) # distance from bottom left corner to midpoint of eyes
emidr=dmid*c(cos(theta+phi),-sin(theta+phi)) # co-ordinates of midpoint in rotated image
sc=1/edist
rasterImage(picx,-sc*emidr[1],-sc*emidr[2],sc*(1-emidr[1]),sc*(dm-emidr[2]),
angle=-theta*180/pi)
#points(0,0,pch=16,cex=2,col="red")
photo_names[431]
photo_names[432]
# Packages
library("magick")
library(animation)
library(grid)
library(jpeg)
library(exifr)
# Directory of photos
photo_dir="~/Personal/Matthew/Photo_a_day/Photos_original/"
# Names of photos
photo_names=list.files(photo_dir,full.names=TRUE)
# Gather co-ordinates of eyes ####
l_eye=data.frame(x=rep(NA,length(photo_names)),y=rep(NA,length(photo_names)));
rownames(l_eye)=photo_names
r_eye=l_eye
metadata=vector(mode="list",length=length(photo_names))
names(metadata)=photo_names
sfile="~/Personal/Matthew/Photo_a_day/locdata.RData"
if (file.exists(sfile)) {
l_eye1=l_eye; r_eye1=r_eye; metadata1=metadata
load(sfile)
inames=intersect(rownames(l_eye),rownames(l_eye1))
l_eye1[inames,]=l_eye[inames,]
r_eye1[inames,]=r_eye[inames,]
metadata1[inames]=metadata[inames]
l_eye=l_eye1
r_eye=r_eye1
metadata=metadata1
}
pmax=length(photo_names)
for (i in 1:pmax) {
#  for (i in 1:length(photo_names)) {
if (!is.finite(l_eye[photo_names[i],1])) {
par(mar=c(0,0,0,0))
plot(0,type="n",xlim=c(0,1),ylim=c(0,1),xaxs="i",yaxs="i")
picx=readJPEG(photo_names[i])
rasterImage(picx,0,0,1,1)
clickloc=as.numeric(gsub("npc","",as.vector(grid.locator("npc"))))*4/3
points(clickloc[1],clickloc[2],pch=16,col="white",cex=3)
clickloc2=as.numeric(gsub("npc","",as.vector(grid.locator("npc"))))*4/3
points(clickloc2[1],clickloc2[2],pch=16,col="black",cex=3)
l_eye[i,]=clickloc
r_eye[i,]=clickloc2
dat=read_exif(photo_names[i])
metadata[[i]]=dat
names(metadata)[[i]]=photo_names[i]
save(l_eye,r_eye,metadata,file=sfile)
Sys.sleep(0.5)
}
print(i)
}
# Sort photos in order by date ####
pmax=max(which(is.finite(l_eye[,1])))
l_eye=l_eye[1:pmax,]
r_eye=r_eye[1:pmax,]
metadata=metadata[1:pmax]
photo_names=photo_names[1:pmax]
length(photo_names)
dates=as.Date(unlist(lapply(metadata,function(x) x$DateTimeOriginal)),format="%Y:%m:%d")
# Fix some dates
dates["/Users/vwbw55/Personal/Matthew/Photo_a_day/Photos_original//0A45D199-BADD-4ECE-A677-01AEE5D2436B.JPG"] = as.Date("2022-09-10")
dates["/Users/vwbw55/Personal/Matthew/Photo_a_day/Photos_original//C7A8743F-7AEA-4B8B-AF7A-B87F52D4120C.JPG"] = as.Date("2022-09-11")
dates["/Users/vwbw55/Personal/Matthew/Photo_a_day/Photos_original//A878329F-9CE8-48F2-B3DF-E341698D4AA7.JPG"] = as.Date("2023-03-25")
dates=dates[names(metadata)]
xord=order(dates)
# Reorder by dates
photo_names=photo_names[xord]
l_eye=l_eye[xord,]
r_eye=r_eye[xord,]
dates=dates[xord]
metadata=metadata[xord]
nphoto=length(photo_names)
# Indices of good photos and facing-forward photos ####
indexfile="~/Personal/Matthew/Photo_a_day/indexdata.RData"
### Photos facing forward and clear
fclear_index=c(2,3,7,9,12,14,16,20,21,22,27,28,30,31,33,34,36,37,41,42,48,50,
53,54,55,57,59,62,65,67,68,69,72,75,77,80,81,82,84,85,86,87,
90,92,93,97,100,101,105,106,108,109,110,112,113,114,115,116,
119,120,121,122,125,126,127,128,130,132,135,136,137,138,139,
141,145,146,147,148,151,152,153,154,158,159,163,164,165,166,
167,169,171,172,174,175,178,181,182,184,185,186,190,192,
193,194,195,197,198,199,200,201,203,204,205,208,209,210,211,
215,216,217,219,220,221,222,223,224,225,227,228,230,231,232,234,
235,237,238,241,242,243,244,250,255,256,258,259,260,263,
264,266,268,272,274,275,277,278,280,281,283,284,285,286,289,
290,291,292,294,297,300,305,308,309,311,312,313,316,320,
322,323,324,326,328,329,331,332,336,340,341,343,345,347,348,
349,351,352,353,357,358,359,362,363,366,368,369,370,372,373,
375,377,382,383,386,391,393,395,399,400,404,409,
411,413,415,416,417,419,422,424,425,426,427,428,429,430,431)
fclear=photo_names[fclear_index]
### Good photos to stop at
fstop_index=c(1,11,39,56,74,109,147,191,199,213,231,
246,258,274,285,311,330,344,368,411,417)
fstop=photo_names[fstop_index]
save(fclear,fstop,file=indexfile)
fi=match(fclear,photo_names)
scxj=seq(2,0.5,length=length(fclear))
j=length(fclear)
i=fi[j]
par(pty="s")
plot(0,xlim=c(-3,3),ylim=c(-3,3),type="n",bty="n",ann=F,xaxt="n",yaxt="n")
picx=readJPEG(photo_names[i])
dm=dim(picx)[1]/dim(picx)[2]
L=as.numeric(l_eye[i,1:2]); R=as.numeric(r_eye[i,1:2]);
L[2]=L[2]*dm; R[2]=R[2]*dm
emid=(L+R)/2 # midpoint of eyes
edist=sqrt(sum((R-L)^2)) # distance between eyes
theta=atan((R[2]-L[2])/(R[1]-L[1])) # angle through which to rotate picture
if (L[1]>R[1]) theta = theta + pi # correction for error
phi=-atan(emid[2]/emid[1]) # angle to midpoint of eyes
dmid=sqrt(sum(emid^2)) # distance from bottom left corner to midpoint of eyes
emidr=dmid*c(cos(theta+phi),-sin(theta+phi)) # co-ordinates of midpoint in rotated image
sc=1/edist
# Adjust brightness
L=as.numeric(l_eye[i,1:2]); R=as.numeric(r_eye[i,1:2]);
L1=L*dim(picx)[2:1];   R1=R*dim(picx)[2:1]; mm = (L1+R1)/2; mm=mm[2:1];
mm[1]=dim(picx)[1]-mm[1]
dd=(3/4)*sqrt(sum((L1-R1)^2))
dx=outer(1:dim(picx)[1],1:dim(picx)[2],function(x,y) sqrt((x-mm[1])^2 + (y-mm[2])^2))
ww=which(dx<dd)
bx1=mean(picx[,,1][ww])
bx2=mean(picx[,,2][ww])
bx3=mean(picx[,,3][ww])
sc1=0.7/bx1; sc2=0.44/bx2; sc3=0.3/bx3
picx[,,1]=pmin(1,picx[,,1]*sc1)
picx[,,2]=pmin(1,picx[,,2]*sc2)
picx[,,3]=pmin(1,picx[,,3]*sc3)
# Plot
s0=scxj[j]
rasterImage(picx,-s0*sc*emidr[1],-s0*sc*emidr[2],s0*sc*(1-emidr[1]),s0*sc*(dm-emidr[2]),
angle=-theta*180/pi)
fi=match(fclear,photo_names)
scxj=seq(2,0.35,length=length(fclear))
i=fi[j]
par(pty="s")
plot(0,xlim=c(-3,3),ylim=c(-3,3),type="n",bty="n",ann=F,xaxt="n",yaxt="n")
picx=readJPEG(photo_names[i])
dm=dim(picx)[1]/dim(picx)[2]
L=as.numeric(l_eye[i,1:2]); R=as.numeric(r_eye[i,1:2]);
L[2]=L[2]*dm; R[2]=R[2]*dm
emid=(L+R)/2 # midpoint of eyes
edist=sqrt(sum((R-L)^2)) # distance between eyes
theta=atan((R[2]-L[2])/(R[1]-L[1])) # angle through which to rotate picture
if (L[1]>R[1]) theta = theta + pi # correction for error
phi=-atan(emid[2]/emid[1]) # angle to midpoint of eyes
dmid=sqrt(sum(emid^2)) # distance from bottom left corner to midpoint of eyes
emidr=dmid*c(cos(theta+phi),-sin(theta+phi)) # co-ordinates of midpoint in rotated image
sc=1/edist
# Adjust brightness
L=as.numeric(l_eye[i,1:2]); R=as.numeric(r_eye[i,1:2]);
L1=L*dim(picx)[2:1];   R1=R*dim(picx)[2:1]; mm = (L1+R1)/2; mm=mm[2:1];
mm[1]=dim(picx)[1]-mm[1]
dd=(3/4)*sqrt(sum((L1-R1)^2))
dx=outer(1:dim(picx)[1],1:dim(picx)[2],function(x,y) sqrt((x-mm[1])^2 + (y-mm[2])^2))
ww=which(dx<dd)
bx1=mean(picx[,,1][ww])
bx2=mean(picx[,,2][ww])
bx3=mean(picx[,,3][ww])
sc1=0.7/bx1; sc2=0.44/bx2; sc3=0.3/bx3
picx[,,1]=pmin(1,picx[,,1]*sc1)
picx[,,2]=pmin(1,picx[,,2]*sc2)
picx[,,3]=pmin(1,picx[,,3]*sc3)
# Plot
s0=scxj[j]
rasterImage(picx,-s0*sc*emidr[1],-s0*sc*emidr[2],s0*sc*(1-emidr[1]),s0*sc*(dm-emidr[2]),
angle=-theta*180/pi)
# Record only face-on ####
ani.record(reset = TRUE)  # clear history before recording
fi=match(fclear,photo_names)
scxj=seq(2,0.35,length=length(fclear))
for (j in 1:length(fclear)) {
i=fi[j]
par(pty="s")
plot(0,xlim=c(-3,3),ylim=c(-3,3),type="n",bty="n",ann=F,xaxt="n",yaxt="n")
picx=readJPEG(photo_names[i])
dm=dim(picx)[1]/dim(picx)[2]
L=as.numeric(l_eye[i,1:2]); R=as.numeric(r_eye[i,1:2]);
L[2]=L[2]*dm; R[2]=R[2]*dm
emid=(L+R)/2 # midpoint of eyes
edist=sqrt(sum((R-L)^2)) # distance between eyes
theta=atan((R[2]-L[2])/(R[1]-L[1])) # angle through which to rotate picture
if (L[1]>R[1]) theta = theta + pi # correction for error
phi=-atan(emid[2]/emid[1]) # angle to midpoint of eyes
dmid=sqrt(sum(emid^2)) # distance from bottom left corner to midpoint of eyes
emidr=dmid*c(cos(theta+phi),-sin(theta+phi)) # co-ordinates of midpoint in rotated image
sc=1/edist
# Adjust brightness
L=as.numeric(l_eye[i,1:2]); R=as.numeric(r_eye[i,1:2]);
L1=L*dim(picx)[2:1];   R1=R*dim(picx)[2:1]; mm = (L1+R1)/2; mm=mm[2:1];
mm[1]=dim(picx)[1]-mm[1]
dd=(3/4)*sqrt(sum((L1-R1)^2))
dx=outer(1:dim(picx)[1],1:dim(picx)[2],function(x,y) sqrt((x-mm[1])^2 + (y-mm[2])^2))
ww=which(dx<dd)
bx1=mean(picx[,,1][ww])
bx2=mean(picx[,,2][ww])
bx3=mean(picx[,,3][ww])
sc1=0.7/bx1; sc2=0.44/bx2; sc3=0.3/bx3
picx[,,1]=pmin(1,picx[,,1]*sc1)
picx[,,2]=pmin(1,picx[,,2]*sc2)
picx[,,3]=pmin(1,picx[,,3]*sc3)
# Plot
s0=scxj[j]
rasterImage(picx,-s0*sc*emidr[1],-s0*sc*emidr[2],s0*sc*(1-emidr[1]),s0*sc*(dm-emidr[2]),
angle=-theta*180/pi)
#points(0,0,pch=16,cex=2,col="red")
ani.record()
print(i)
}
# Save gif of only face-on photos ####
library(versions)
install.versions("randomForestSRC","2.6.0")
help(install.packages)
library(remotes)
require(remotes)
install_version("randomForestSRC", version = "2.6.0", repos = "http://cran.us.r-project.org")
library(randomForestSRC)
setwd("Research/CTEPH/PEA_risk/Git/PEA_risk/")
##**********************************************************************
##  Risk prediction in PEA                                          ####
##  Supporting code for main analyses
##  James Liley
##  9/3/19
##**********************************************************************
##**********************************************************************
## Switches                                                         ####
##**********************************************************************
do_assoc_test=TRUE # set to TRUE to do association tests
normalise=F
# force redo
force_redo_dm=FALSE
force_redo_5m=FALSE
force_redo_dq=FALSE
force_redo_all=FALSE
# missingness
if (!exists("low_missingness")) low_missingness=FALSE # Will be set in main pipeline
# Write to file or not
write_to_file=TRUE
# random seed
set.seed(1)
##**********************************************************************
## Set data and output directories                                  ####
##**********************************************************************
## Data location
datadir="../../Data/"
# Output location
outdir="Outputs/"
# Prefix all saved filenames with this according to missingness
if (low_missingness) prefix="nmiss_" else prefix=""
##**********************************************************************
## Packages and scripts                                             ####
##**********************************************************************
library(glmnet)
library(randomForest)
library(snpStats)
library(survival)
library(randomForestSRC) # Version
library(pec)
library(penalized)
library(cvAUC)
library(risksetROC)
library(lmtest)
source("Code/auxiliary.R") # Auxiliary functions
##**********************************************************************
## Set data and output directories                                  ####
##**********************************************************************
## Data location
datadir="../../Data/"
# Output location
outdir="Outputs/"
##**********************************************************************
## Load data from main analysis                                     ####
##**********************************************************************
load(paste0(datadir,"Temp_data/Workspaces/discovery.RData"))
##**********************************************************************
## Process outputs for Shiny                                        ####
##**********************************************************************
# Preop data (preliminary)
Xp=Xall[,intersect(colnames(Xall),preop_predictors)]
survfit=predict(mod_5m_preop,Xp)
